package myfirstPackage

import breeze.linalg._

import breeze.stats.distributions._
import breeze.stats.DescriptiveStats._
import scala.collection.mutable.ArrayBuffer
import java.io.File


object Main {
  def main(args: Array[String]): Unit = {

    val fileName:String = args(0)
    val nothing = args(1)
    val predictDataFileName:String = args(2)

    val df = csvread(new File(fileName))
    
    val rowsNumber = df.rows
    val columnsNumber = df.columns
      
    val numberfeatures = df.columns

    split = 0.7
      
    val xTrain = df(0 to split*rowsNumber.toInt, 0 to columnsNumber-1)
    val xTest  = df(split*rowsNumber.toInt+1 to rowsNumber, 0 to columnsNumber-1)               
    
    val xTrain = df(::, 1 to columnsNumber)
    val yTest  = df(::, 1 to columnsNumber)
    
    val learningRate = 1e-7
    val numberOfIterations = 100
    
    val xTrainMatrix = DenseMatrix.horzcat(xTrain, DenseMatrix.ones[Double](xTrain.rows, 1))
    val yTrainMatrix = DenseMatrix(yTrain).t

    var beta = DenseMatrix.zeros[Double](numberfeatures+1,1)
    var beta_tmp = DenseMatrix.zeros[Double](numberfeatures+1,1)

    val train_error = 0
    val valid_error = 0
    val mse = 0
      
    for (iter <- 0 to numberOfIterations){
        train_error = (xTrainMatrix * beta) - yTrainMatrix

        for(i <- 0 to df.columns-1) {
          
            beta(i,0)  = beta(i,0) - learningRate / rowsNumber * sum(error.t * xTrainMatrix(::,i))

          }

        mse  = sum(train_error.t * train_error)  /  rowsNumber
        println( s"Training_loss $mse")

        }

    val xValMatrix = DenseMatrix.horzcat(xVal, DenseMatrix.ones[Double](xVal.rows, 1))
    val yValMatrix = DenseMatrix(yVal).t
    
    val predictions = xValMatrix * beta
    
    val valid_error = predictions - yValMatrix
    
    val valid_mse = sum(valid_error.t * valid_error) / (rowsNumber - split*rowsNumber.toInt+1)


    println( s"\n Validation_loss $val_mse")
    csvwrite(new File(predictDataFileName), predicts, ',')

  }
}
